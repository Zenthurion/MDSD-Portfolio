/*
 * generated by Xtext 2.16.0
 */
package dk.sdu.mdsd.guilang.validation

import com.google.inject.Inject
import dk.sdu.mdsd.guilang.guilang.Entity
import dk.sdu.mdsd.guilang.guilang.GuilangPackage
import dk.sdu.mdsd.guilang.guilang.Main
import dk.sdu.mdsd.guilang.guilang.Specification
import dk.sdu.mdsd.guilang.guilang.Template
import dk.sdu.mdsd.guilang.guilang.UnitInstance
import dk.sdu.mdsd.guilang.utils.EntitySpecificationsProvider
import dk.sdu.mdsd.guilang.utils.GuilangModelUtils
import java.util.List
import org.eclipse.xtext.validation.Check
import dk.sdu.mdsd.guilang.guilang.Template

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class GuilangValidator extends AbstractGuilangValidator {

	@Inject extension EntitySpecificationsProvider	
	@Inject extension GuilangModelUtils		
	
	public static val INVALID_NAME = 'invalidName'
	public static val INVALID_OPTION = 'invalidOption'
	public static val CYCLIC_UNIT = 'cyclicUnit'

	/**
	 * Ensures that only allowed options are assigned to a specific entity
	 */
	@Check
	def checkValidOptions(Specification spec) {
		var correctOptions = getSpecifications(spec.ref.entity.class)
		
		var int index = 0
		for (o : spec.options) {
			var flag = false;
			for (c : correctOptions) {
				if(c.option.isInstance(o)) {
					flag = true
				}
			}	
			if(!flag) {
				error('''«o.class.shortName» is not a valid option for an entity of type «spec.ref.entity.class.shortName»''', GuilangPackage.Literals.SPECIFICATION__OPTIONS, index, INVALID_OPTION)
			}
			index++
		}
	} 
	
	// check this in scoping?
//	@Check
//	def checkCircularUnitInstance(UnitInstance unitInstance) {
//
//		if(unitInstance.isNested(null)) {
//			error('''Cyclic creation of Unit «unitInstance.unit.name» is not allowed''', 
//						GuilangPackage.Literals.UNIT_INSTANCE__UNIT, 
//						CYCLIC_UNIT, 
//						unitInstance.unit.name)
//		}
//			
//		
//	}
//	
//	private def boolean isNested(UnitInstance original, UnitInstance toCheck) {
//		var nested = getEntities(if(toCheck === null) original.unit.contents.layout else toCheck.unit.contents.layout)
//		println("Checking " + original.unit.name + " against " + toCheck.unit.name)
//		for(instance : nested) {
//			if(instance instanceof UnitInstance) {
//				if(instance.unit.name == original.unit.name) {
//					return true
//				}
//				else {
//					if(original.isNested(toCheck)) {
//						return true
//					}
//				}
//			}
//		}
//		
//		return false
//	}


	@Check
	def checkMainNameStartWithCapital(Main main) {
		if (!Character.isUpperCase(main.name.charAt(0))) {
			warning("Main name should start with a capital letter", GuilangPackage.Literals.UNIT__NAME,
				INVALID_NAME)
		}
	}

	def private getShortName(Class<?> c) {
		var res = c.canonicalName
		return res.substring(res.lastIndexOf('.') + 1, res.length - 4)
	}

	@Check
	def checkMainNameMatchesFileName(Main main) {
		var name = main.eResource.URI.path
		name = name.subSequence(name.lastIndexOf("/") + 1, name.length - 4).toString
		if (!name.equalsIgnoreCase(main.name)) {
			warning("Main name should match the filename", GuilangPackage.Literals.UNIT__NAME,
				INVALID_NAME)
		}
	}


	@Check
	def checkTemplateNamesStartWithCapital(Template template) {
		if (!Character.isUpperCase(template.name.charAt(0))) {
			warning("Template names should start with a capital letter", GuilangPackage.Literals.UNIT__NAME,
				INVALID_NAME)
		}
	}

	@Check
	def checkEntityNamesStartWithLowerCase(Entity entity) {
		if (entity.name !== null && Character.isUpperCase(entity.name.charAt(0))) {
			warning("Entity names should start with a lowercase letter", GuilangPackage.Literals.ENTITY__NAME,
				INVALID_NAME)
		}
	}
}
