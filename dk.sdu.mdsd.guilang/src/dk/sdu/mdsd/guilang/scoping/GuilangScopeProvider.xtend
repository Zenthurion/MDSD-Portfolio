/*
 * generated by Xtext 2.16.0
 */
package dk.sdu.mdsd.guilang.scoping

import com.google.inject.Inject
import dk.sdu.mdsd.guilang.guilang.DotRef
import dk.sdu.mdsd.guilang.guilang.EntityRef
import dk.sdu.mdsd.guilang.guilang.GuilangPackage
import dk.sdu.mdsd.guilang.guilang.Specification
import dk.sdu.mdsd.guilang.guilang.Specifications
import dk.sdu.mdsd.guilang.guilang.Unit
import dk.sdu.mdsd.guilang.guilang.UnitInstance
import dk.sdu.mdsd.guilang.guilang.UnitInstanceOption
import dk.sdu.mdsd.guilang.guilang.impl.UnitInstanceImpl
import dk.sdu.mdsd.guilang.utils.GuilangModelUtils
import java.util.ArrayList
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.SimpleScope

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class GuilangScopeProvider extends AbstractGuilangScopeProvider {
	@Inject extension GuilangModelUtils

	override IScope getScope(EObject context, EReference reference) {
		if (reference === GuilangPackage.Literals.REF__ENTITY && context instanceof DotRef) {

			return getDotRefTailScope(context, reference)

		} else if (reference === GuilangPackage.Literals.REF__ENTITY) {

			return getEntityRefEntityScope(context, reference)

		} else if (reference === GuilangPackage.Literals.UNIT_INSTANCE__UNIT) {
			
			return getUnitInstanceScope(context, reference)
			
		}

		//println("Using default scope > " + context + " <-> " + reference)
		return super.getScope(context, reference)
	}
	
	def IScope getUnitInstanceScope(EObject context, EReference reference) {
		var scope = super.getScope(context, reference)
		var elements = new ArrayList<IEObjectDescription>
		elements.addAll(scope.allElements)
		val filtered = new ArrayList<IEObjectDescription>
		
		for(e : elements) {
			var obj = e.EObjectOrProxy
			if((e.EObjectOrProxy instanceof Unit) && !(e.EObjectOrProxy as Unit).hasCyclicReference){
				filtered.add(e)
			}
		}
		
		return new SimpleScope(filtered)
	}
	

	def IScope getEntityRefEntityScope(EObject context, EReference reference) {
		if (context instanceof Specifications) { // TODO: This appears to work
			val entities = EcoreUtil2.getContainerOfType(context, Unit).getEntities
			return Scopes.scopeFor(entities)
		} else if (context instanceof EntityRef) { // TODO: This appears to work
			val unitInstanceOption = EcoreUtil2.getContainerOfType(context, UnitInstanceOption)
			if (unitInstanceOption !== null) {
				val entity = (unitInstanceOption.eContainer as Specification).ref.entity
				if (entity instanceof UnitInstanceImpl) {
					val entities = entity.getEntities
					return Scopes.scopeFor(entities)
				}
			}
			val entities = EcoreUtil2.getContainerOfType(context, Unit).getEntities
			return Scopes.scopeFor(entities)
		} else if (context instanceof Specification) {
			val ref = context.ref
			if (ref instanceof EntityRef) {
				val entity = ref.entity
				if (entity instanceof UnitInstance) {
					val entities = entity.unit.getEntities
					return Scopes.scopeFor(entities)

				} else {
					val unitInstanceOption = EcoreUtil2.getContainerOfType(context, UnitInstanceOption)
					if (unitInstanceOption !== null) {
						if (entity !== null) {
							return IScope.NULLSCOPE // This is a regular entity, so no further entities are in scope
						}
						val unit = (unitInstanceOption.eContainer as Specification).ref.entity as UnitInstance
						val entities = unit.getEntities
						return Scopes.scopeFor(entities)
					} else if (entity !== null) {
						return IScope.NULLSCOPE // This is a regular entity, so no further entities are in scope
					}
					val owner = EcoreUtil2.getContainerOfType(context, Unit)
					val entities = owner.getEntities
					return Scopes.scopeFor(entities)
				}
			}
		}
		// No further scoping available. Should only occur when the entity is a primitive
		return IScope.NULLSCOPE
	}

	def IScope getDotRefTailScope(EObject context, EReference reference) {
		if (context instanceof DotRef) { // TODO: This appears to work
			var ref = context.ref
			val hierarchy = ref.hierarchy
			if (ref instanceof EntityRef) {
				var entity = ref.entity
				if (entity instanceof UnitInstance) {
					return Scopes.scopeFor(entity.getEntities) // .filter[e|!hierarchy.contains(e)]
				} else {
					return IScope.NULLSCOPE
				}
			} else if (ref instanceof DotRef) {
				var tail = ref.entity
				if (tail instanceof UnitInstance) {
					return Scopes.scopeFor(tail.getEntities) // .filter[e|!hierarchy.contains(e)]
				}
			}
		}
		return IScope.NULLSCOPE
	}

}
